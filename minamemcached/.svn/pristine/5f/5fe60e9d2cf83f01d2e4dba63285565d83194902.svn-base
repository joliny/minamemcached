///**
// * 
// */
//package org.coral.common.memcached.codec;
//
//import java.nio.charset.Charset;
//
//import org.apache.commons.logging.Log;
//import org.apache.commons.logging.LogFactory;
//import org.apache.mina.core.buffer.IoBuffer;
//
//@Deprecated
//public class CachedByteBuffer {
//
//	private static final Log log = LogFactory.getLog(CachedByteBuffer.class);
//
//	private byte[] buf = new byte[10240];
//	private int begin = 0;
//	private int length = 0;
//
//	/**
//	 * reset begin and limit
//	 * 
//	 * @param begin
//	 * @param limit
//	 */
//	public void reset(int begin, int limit) {
//		this.begin = begin;
//		this.length = limit;
//	}
//
//	public int getLength() {
//		return length;
//	}
//
//	public byte[] getBuf() {
//		return buf;
//	}
//
//	public int getBegin() {
//		return begin;
//	}
//
//	public int getSize() {
//		return buf.length;
//	}
//
//	/**
//	 * move bytes in [begin , begin+limit) to [0, limit) and set begin=0
//	 */
//	private void move2head() {
//		System.arraycopy(buf, begin, buf, 0, length);
//		begin = 0;
//	}
//
//	/**
//	 * skip offset bytes , if limit==0 ( no validate data ) then set begin=0
//	 * 
//	 * @param offset
//	 */
//	public void skip(int offset) {
//		right(offset);
//	}
//
//	private void right(int offset) {
//		this.begin += offset;
//		this.length -= offset;
//
//		if (this.length == 0) {
//			this.begin = 0;
//		}
//	}
//
//	/**
//	 * read all bytes from in to buf , limit += in.remaining()
//	 * 
//	 * @param in
//	 */
//	public void read(IoBuffer in) {
//
//		if (in.remaining() + length > buf.length) {
//			if (log.isInfoEnabled()) {
//				log
//						.info(String
//								.format(
//										"recving buf is too short  ! begin=%d , limit=%d  , buf size=%d ,  remaining=%d",
//										getBegin(), getLength(),
//										this.buf.length, in.remaining()));
//
//			}
//
//			byte[] newbuf = new byte[Math.max(buf.length, in.remaining()
//					+ length) * 2];
//
//			System.arraycopy(buf, begin, newbuf, 0, length);
//			begin = 0;
//			buf = newbuf;
//			newbuf = null;
//			if (log.isInfoEnabled()) {
//				log
//						.info(String
//								.format(
//										"alloc new buf ! begin=%d , limit=%d  , buf size=%d ,  remaining=%d",
//										getBegin(), getLength(),
//										this.buf.length, in.remaining()));
//
//			}
//
//		}
//		if (in.remaining() + begin + length > buf.length) {
//			if (log.isTraceEnabled()) {
//				log.trace(String.format(
//						"copy begin:limit=%d:%d to 0:%d , remaining=%d", begin,
//						length, length, in.remaining()));
//			}
//			move2head();
//		}
//		int offset = in.remaining();
//		in.get(buf, begin + length, offset);
//		this.length += offset;
//
//	}
//
//	public String getString(int size, Charset charset) {
//		if (size > this.length) {
//			throw new RuntimeException(String.format(
//					"No enough bytes.limit=%d , size=%d", this.length, size));
//		}
//		String str = new String(buf, begin, size, charset);
//		right(size);
//		return str;
//	}
//
//	/**
//	 * find the first byte which is equals to b in [begin , begin+limit)
//	 * 
//	 * @param b
//	 * @return -1 : NOT finded offset to the begin : finded
//	 */
//	private int find(byte b) {
//
//		for (int i = 0; i < length; i++) {
//			if (buf[begin + i] == b) {
//				return i;
//			}
//		}
//
//		return -1;
//	}
//
//	/**
//	 * get the first string which is ended with delimer in [begin , begin+limit)
//	 * 
//	 * @param delimer
//	 * @param charset
//	 * @return
//	 */
//	public String getString(String delimer, Charset charset) {
//
//		byte[] delimerBuf = delimer.getBytes(charset);
//		int offset = find(delimerBuf[0]);
//		if (offset == -1 || offset + delimerBuf.length > this.length) {
//			return null;
//		}
//		for (int i = 1; i < delimerBuf.length; i++) {
//			if (this.buf[begin + offset + i] != delimerBuf[i]) {
//				return null;
//			}
//
//		}
//		return getString(offset + delimerBuf.length, charset);
//	}
//
//	public byte[] getBytes(int size) {
//		if (size > length) {
//			throw new IllegalArgumentException();
//		}
//
//		byte[] result = new byte[size];
//		System.arraycopy(this.buf, begin, result, 0, size);
//		right(size);
//		return result;
//
//	}
//
//}