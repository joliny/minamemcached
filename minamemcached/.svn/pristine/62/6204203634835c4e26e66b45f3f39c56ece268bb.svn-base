//package org.coral.common.memcached.codec;
//
//import java.util.concurrent.LinkedBlockingQueue;
//
//import org.apache.commons.logging.Log;
//import org.apache.commons.logging.LogFactory;
//import org.apache.mina.core.buffer.IoBuffer;
//import org.apache.mina.core.session.IoSession;
//import org.apache.mina.filter.codec.ProtocolDecoderAdapter;
//import org.apache.mina.filter.codec.ProtocolDecoderOutput;
//import org.coral.common.memcached.MemcachedConstants;
//import org.coral.common.memcached.context.RequestContext;
//
//@Deprecated
//public class CachedReponseDecoder extends ProtocolDecoderAdapter {
//
//	private static final Log log = LogFactory
//			.getLog(CachedReponseDecoder.class);
//
//	@SuppressWarnings("unchecked")
//	public void decode(IoSession session, IoBuffer in, ProtocolDecoderOutput out)
//			throws Exception {
//
//		CachedByteBuffer cacheBuf = (CachedByteBuffer) session
//				.getAttribute(MemcachedConstants.KEY_CACHED_BYTE);
//		cacheBuf.read(in);
//
//		int i = 0;
//		long t=System.nanoTime();
//		try {
//
//			for (;;) {
//				if (cacheBuf.getLength() == 0) {
//					return;
//				}
//				LinkedBlockingQueue<RequestContext> queue = (LinkedBlockingQueue<RequestContext>) session
//						.getAttribute(MemcachedConstants.KEY_COMMAND_QUEUE);
//
//				RequestContext item = queue.peek();
//
//				if (item == null) {
//					return;
//				}
//				
//				if(item.getReponse() ==null){
//					item.setReponse(item.getCommand().create());
//				}
//
//				boolean result = item.getReponse().parse(cacheBuf,
//						MemcachedConstants.DEFAULT_CHARSET);
//
//				if (result) {
//					out.write(item);
//					queue.remove();
//					i++;
//				} else {
//					return;
//				}
//
//			}
//		} finally {
//			if(log.isTraceEnabled()){
//				log.trace(String.format("Deal with command number :%d , using %d mm , remaining =%d" , i , System.nanoTime() - t , in.remaining()));
//			}
//		}
//
//	}
//
//}
